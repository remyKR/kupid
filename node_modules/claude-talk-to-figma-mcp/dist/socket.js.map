{"version":3,"sources":["../src/socket.ts"],"sourcesContent":["import { Server, ServerWebSocket } from \"bun\";\n\n// Enhanced logging system\nconst logger = {\n  info: (message: string, ...args: any[]) => {\n    console.log(`[INFO] ${message}`, ...args);\n  },\n  debug: (message: string, ...args: any[]) => {\n    console.log(`[DEBUG] ${message}`, ...args);\n  },\n  warn: (message: string, ...args: any[]) => {\n    console.warn(`[WARN] ${message}`, ...args);\n  },\n  error: (message: string, ...args: any[]) => {\n    console.error(`[ERROR] ${message}`, ...args);\n  }\n};\n\n// Store clients by channel\nconst channels = new Map<string, Set<ServerWebSocket<any>>>();\n\n// Keep track of channel statistics\nconst stats = {\n  totalConnections: 0,\n  activeConnections: 0,\n  messagesSent: 0,\n  messagesReceived: 0,\n  errors: 0\n};\n\nfunction handleConnection(ws: ServerWebSocket<any>) {\n  // Track connection statistics\n  stats.totalConnections++;\n  stats.activeConnections++;\n  \n  // Assign a unique client ID for better tracking\n  const clientId = `client_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n  ws.data = { clientId };\n  \n  // Don't add to clients immediately - wait for channel join\n  logger.info(`New client connected: ${clientId}`);\n\n  // Send welcome message to the new client\n  try {\n    ws.send(JSON.stringify({\n      type: \"system\",\n      message: \"Please join a channel to start communicating with Figma\",\n    }));\n  } catch (error) {\n    logger.error(`Failed to send welcome message to client ${clientId}:`, error);\n    stats.errors++;\n  }\n\n  ws.close = () => {\n    logger.info(`Client disconnected: ${clientId}`);\n    stats.activeConnections--;\n\n    // Remove client from their channel\n    channels.forEach((clients, channelName) => {\n      if (clients.has(ws)) {\n        clients.delete(ws);\n        logger.debug(`Removed client ${clientId} from channel: ${channelName}`);\n\n        // Notify other clients in same channel\n        try {\n          clients.forEach((client) => {\n            if (client.readyState === WebSocket.OPEN) {\n              client.send(JSON.stringify({\n                type: \"system\",\n                message: \"A client has left the channel\",\n                channel: channelName\n              }));\n              stats.messagesSent++;\n            }\n          });\n        } catch (error) {\n          logger.error(`Error notifying channel ${channelName} about client disconnect:`, error);\n          stats.errors++;\n        }\n      }\n    });\n  };\n}\n\nconst server = Bun.serve({\n  port: 3055,\n  // uncomment this to allow connections in windows wsl\n  // hostname: \"0.0.0.0\",\n  fetch(req: Request, server: Server) {\n    const url = new URL(req.url);\n    \n    // Log incoming requests\n    logger.debug(`Received ${req.method} request to ${url.pathname}`);\n    \n    // Handle CORS preflight\n    if (req.method === \"OPTIONS\") {\n      return new Response(null, {\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n          \"Access-Control-Allow-Methods\": \"GET, POST, OPTIONS\",\n          \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n        },\n      });\n    }\n\n    // Handle status endpoint\n    if (url.pathname === \"/status\") {\n      return new Response(JSON.stringify({\n        status: \"running\",\n        uptime: process.uptime(),\n        stats\n      }), {\n        headers: {\n          \"Content-Type\": \"application/json\",\n          \"Access-Control-Allow-Origin\": \"*\"\n        }\n      });\n    }\n\n    // Handle WebSocket upgrade\n    try {\n      const success = server.upgrade(req, {\n        headers: {\n          \"Access-Control-Allow-Origin\": \"*\",\n        },\n      });\n\n      if (success) {\n        return; // Upgraded to WebSocket\n      }\n    } catch (error) {\n      logger.error(\"Failed to upgrade WebSocket connection:\", error);\n      stats.errors++;\n      return new Response(\"Failed to upgrade to WebSocket\", { status: 500 });\n    }\n\n    // Return response for non-WebSocket requests\n    return new Response(\"Claude to Figma WebSocket server running. Try connecting with a WebSocket client.\", {\n      headers: {\n        \"Content-Type\": \"text/plain\",\n        \"Access-Control-Allow-Origin\": \"*\",\n      },\n    });\n  },\n  websocket: {\n    open: handleConnection,\n    message(ws: ServerWebSocket<any>, message: string | Buffer) {\n      try {\n        stats.messagesReceived++;\n        const clientId = ws.data?.clientId || \"unknown\";\n        \n        logger.debug(`Received message from client ${clientId}:`, typeof message === 'string' ? message : '<binary>');\n        const data = JSON.parse(message as string);\n\n        if (data.type === \"join\") {\n          const channelName = data.channel;\n          if (!channelName || typeof channelName !== \"string\") {\n            logger.warn(`Client ${clientId} attempted to join without a valid channel name`);\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"Channel name is required\"\n            }));\n            stats.messagesSent++;\n            return;\n          }\n\n          // Create channel if it doesn't exist\n          if (!channels.has(channelName)) {\n            logger.info(`Creating new channel: ${channelName}`);\n            channels.set(channelName, new Set());\n          }\n\n          // Add client to channel\n          const channelClients = channels.get(channelName)!;\n          channelClients.add(ws);\n          logger.info(`Client ${clientId} joined channel: ${channelName}`);\n\n          // Notify client they joined successfully\n          try {\n            ws.send(JSON.stringify({\n              type: \"system\",\n              message: `Joined channel: ${channelName}`,\n              channel: channelName\n            }));\n            stats.messagesSent++;\n\n            ws.send(JSON.stringify({\n              type: \"system\",\n              message: {\n                id: data.id,\n                result: \"Connected to channel: \" + channelName,\n              },\n              channel: channelName\n            }));\n            stats.messagesSent++;\n            \n            logger.debug(`Connection confirmation sent to client ${clientId} for channel ${channelName}`);\n          } catch (error) {\n            logger.error(`Failed to send join confirmation to client ${clientId}:`, error);\n            stats.errors++;\n          }\n\n          // Notify other clients in channel\n          try {\n            let notificationCount = 0;\n            channelClients.forEach((client) => {\n              if (client !== ws && client.readyState === WebSocket.OPEN) {\n                client.send(JSON.stringify({\n                  type: \"system\",\n                  message: \"A new client has joined the channel\",\n                  channel: channelName\n                }));\n                stats.messagesSent++;\n                notificationCount++;\n              }\n            });\n            if (notificationCount > 0) {\n              logger.debug(`Notified ${notificationCount} other clients in channel ${channelName}`);\n            }\n          } catch (error) {\n            logger.error(`Error notifying channel about new client:`, error);\n            stats.errors++;\n          }\n          \n          return;\n        }\n\n        // Handle regular messages\n        if (data.type === \"message\") {\n          const channelName = data.channel;\n          if (!channelName || typeof channelName !== \"string\") {\n            logger.warn(`Client ${clientId} sent message without a valid channel name`);\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"Channel name is required\"\n            }));\n            stats.messagesSent++;\n            return;\n          }\n\n          const channelClients = channels.get(channelName);\n          if (!channelClients || !channelClients.has(ws)) {\n            logger.warn(`Client ${clientId} attempted to send to channel ${channelName} without joining first`);\n            ws.send(JSON.stringify({\n              type: \"error\",\n              message: \"You must join the channel first\"\n            }));\n            stats.messagesSent++;\n            return;\n          }\n\n          // Broadcast to all clients in the channel\n          try {\n            let broadcastCount = 0;\n            channelClients.forEach((client) => {\n              if (client.readyState === WebSocket.OPEN) {\n                logger.debug(`Broadcasting message to client in channel ${channelName}`);\n                client.send(JSON.stringify({\n                  type: \"broadcast\",\n                  message: data.message,\n                  sender: client === ws ? \"You\" : \"User\",\n                  channel: channelName\n                }));\n                stats.messagesSent++;\n                broadcastCount++;\n              }\n            });\n            logger.info(`Broadcasted message to ${broadcastCount} clients in channel ${channelName}`);\n          } catch (error) {\n            logger.error(`Error broadcasting message to channel ${channelName}:`, error);\n            stats.errors++;\n          }\n        }\n        \n        // Handle progress updates\n        if (data.type === \"progress_update\") {\n          const channelName = data.channel;\n          if (!channelName || typeof channelName !== \"string\") {\n            logger.warn(`Client ${clientId} sent progress update without a valid channel name`);\n            return;\n          }\n\n          const channelClients = channels.get(channelName);\n          if (!channelClients) {\n            logger.warn(`Progress update for non-existent channel: ${channelName}`);\n            return;\n          }\n\n          logger.debug(`Progress update for command ${data.id} in channel ${channelName}: ${data.message?.data?.status || 'unknown'} - ${data.message?.data?.progress || 0}%`);\n          \n          // Broadcast progress update to all clients in the channel\n          try {\n            channelClients.forEach((client) => {\n              if (client.readyState === WebSocket.OPEN) {\n                client.send(JSON.stringify(data));\n                stats.messagesSent++;\n              }\n            });\n          } catch (error) {\n            logger.error(`Error broadcasting progress update:`, error);\n            stats.errors++;\n          }\n        }\n        \n      } catch (err) {\n        stats.errors++;\n        logger.error(\"Error handling message:\", err);\n        try {\n          // Send error back to client\n          ws.send(JSON.stringify({\n            type: \"error\",\n            message: \"Error processing your message: \" + (err instanceof Error ? err.message : String(err))\n          }));\n          stats.messagesSent++;\n        } catch (sendError) {\n          logger.error(\"Failed to send error message to client:\", sendError);\n        }\n      }\n    },\n    close(ws: ServerWebSocket<any>, code: number, reason: string) {\n      const clientId = ws.data?.clientId || \"unknown\";\n      logger.info(`WebSocket closed for client ${clientId}: Code ${code}, Reason: ${reason || 'No reason provided'}`);\n      \n      // Remove client from their channel\n      channels.forEach((clients, channelName) => {\n        if (clients.delete(ws)) {\n          logger.debug(`Removed client ${clientId} from channel ${channelName} due to connection close`);\n        }\n      });\n      \n      stats.activeConnections--;\n    },\n    drain(ws: ServerWebSocket<any>) {\n      const clientId = ws.data?.clientId || \"unknown\";\n      logger.debug(`WebSocket backpressure relieved for client ${clientId}`);\n    }\n  }\n});\n\nlogger.info(`Claude to Figma WebSocket server running on port ${server.port}`);\nlogger.info(`Status endpoint available at http://localhost:${server.port}/status`);\n\n// Print server stats every 5 minutes\nsetInterval(() => {\n  logger.info(\"Server stats:\", {\n    channels: channels.size,\n    ...stats\n  });\n}, 5 * 60 * 1000);\n"],"mappings":"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","names":["server"]}