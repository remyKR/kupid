#!/usr/bin/env node
"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));

// src/talk_to_figma_mcp/server.ts
var import_mcp = require("@modelcontextprotocol/sdk/server/mcp.js");
var import_stdio = require("@modelcontextprotocol/sdk/server/stdio.js");

// src/talk_to_figma_mcp/config/config.ts
var args = process.argv.slice(2);
var serverArg = args.find((arg) => arg.startsWith("--server="));
var portArg = args.find((arg) => arg.startsWith("--port="));
var reconnectArg = args.find((arg) => arg.startsWith("--reconnect-interval="));
var serverUrl = serverArg ? serverArg.split("=")[1] : "localhost";
var defaultPort = portArg ? parseInt(portArg.split("=")[1], 10) : 3055;
var reconnectInterval = reconnectArg ? parseInt(reconnectArg.split("=")[1], 10) : 2e3;
var WS_URL = serverUrl === "localhost" ? `ws://${serverUrl}` : `wss://${serverUrl}`;
var SERVER_CONFIG = {
  name: "ClaudeTalkToFigmaMCP",
  description: "Claude MCP Plugin for Figma",
  version: "0.4.0"
};

// src/talk_to_figma_mcp/utils/logger.ts
var logger = {
  info: (message) => process.stderr.write(`[INFO] ${message}
`),
  debug: (message) => process.stderr.write(`[DEBUG] ${message}
`),
  warn: (message) => process.stderr.write(`[WARN] ${message}
`),
  error: (message) => process.stderr.write(`[ERROR] ${message}
`),
  log: (message) => process.stderr.write(`[LOG] ${message}
`)
};

// src/talk_to_figma_mcp/utils/websocket.ts
var import_ws = __toESM(require("ws"), 1);
var import_uuid = require("uuid");
var ws = null;
var currentChannel = null;
var pendingRequests = /* @__PURE__ */ new Map();
function connectToFigma(port = defaultPort) {
  if (ws && ws.readyState === import_ws.default.OPEN) {
    logger.info("Already connected to Figma");
    return;
  }
  if (ws && ws.readyState === import_ws.default.CONNECTING) {
    logger.info("Connection to Figma is already in progress");
    return;
  }
  if (ws && (ws.readyState === import_ws.default.CLOSING || ws.readyState === import_ws.default.CLOSED)) {
    ws.removeAllListeners();
    ws = null;
  }
  const wsUrl = serverUrl === "localhost" ? `${WS_URL}:${port}` : WS_URL;
  logger.info(`Connecting to Figma socket server at ${wsUrl}...`);
  try {
    ws = new import_ws.default(wsUrl);
    const connectionTimeout = setTimeout(() => {
      if (ws && ws.readyState === import_ws.default.CONNECTING) {
        logger.error("Connection to Figma timed out");
        ws.terminate();
      }
    }, 1e4);
    ws.on("open", () => {
      clearTimeout(connectionTimeout);
      logger.info("Connected to Figma socket server");
      currentChannel = null;
    });
    ws.on("message", (data) => {
      try {
        const json = JSON.parse(data);
        if (json.type === "progress_update") {
          const progressData = json.message.data;
          const requestId = json.id || "";
          if (requestId && pendingRequests.has(requestId)) {
            const request = pendingRequests.get(requestId);
            request.lastActivity = Date.now();
            clearTimeout(request.timeout);
            request.timeout = setTimeout(() => {
              if (pendingRequests.has(requestId)) {
                logger.error(`Request ${requestId} timed out after extended period of inactivity`);
                pendingRequests.delete(requestId);
                request.reject(new Error("Request to Figma timed out"));
              }
            }, 6e4);
            logger.info(`Progress update for ${progressData.commandType}: ${progressData.progress}% - ${progressData.message}`);
            if (progressData.status === "completed" && progressData.progress === 100) {
              logger.info(`Operation ${progressData.commandType} completed, waiting for final result`);
            }
          }
          return;
        }
        const myResponse = json.message;
        logger.debug(`Received message: ${JSON.stringify(myResponse)}`);
        logger.log("myResponse" + JSON.stringify(myResponse));
        if (myResponse.id && pendingRequests.has(myResponse.id) && myResponse.result) {
          const request = pendingRequests.get(myResponse.id);
          clearTimeout(request.timeout);
          if (myResponse.error) {
            logger.error(`Error from Figma: ${myResponse.error}`);
            request.reject(new Error(myResponse.error));
          } else {
            if (myResponse.result) {
              request.resolve(myResponse.result);
            }
          }
          pendingRequests.delete(myResponse.id);
        } else {
          logger.info(`Received broadcast message: ${JSON.stringify(myResponse)}`);
        }
      } catch (error) {
        logger.error(`Error parsing message: ${error instanceof Error ? error.message : String(error)}`);
      }
    });
    ws.on("error", (error) => {
      logger.error(`Socket error: ${error}`);
    });
    ws.on("close", (code, reason) => {
      clearTimeout(connectionTimeout);
      logger.info(`Disconnected from Figma socket server with code ${code} and reason: ${reason || "No reason provided"}`);
      ws = null;
      for (const [id, request] of pendingRequests.entries()) {
        clearTimeout(request.timeout);
        request.reject(new Error(`Connection closed with code ${code}: ${reason || "No reason provided"}`));
        pendingRequests.delete(id);
      }
      const backoff = Math.min(3e4, reconnectInterval * Math.pow(1.5, Math.floor(Math.random() * 5)));
      logger.info(`Attempting to reconnect in ${backoff / 1e3} seconds...`);
      setTimeout(() => connectToFigma(port), backoff);
    });
  } catch (error) {
    logger.error(`Failed to create WebSocket connection: ${error instanceof Error ? error.message : String(error)}`);
    setTimeout(() => connectToFigma(port), reconnectInterval);
  }
}
async function joinChannel(channelName) {
  if (!ws || ws.readyState !== import_ws.default.OPEN) {
    throw new Error("Not connected to Figma");
  }
  try {
    await sendCommandToFigma("join", { channel: channelName });
    currentChannel = channelName;
    logger.info(`Joined channel: ${channelName}`);
  } catch (error) {
    logger.error(`Failed to join channel: ${error instanceof Error ? error.message : String(error)}`);
    throw error;
  }
}
function sendCommandToFigma(command, params = {}, timeoutMs = 3e4) {
  return new Promise((resolve, reject) => {
    if (!ws || ws.readyState !== import_ws.default.OPEN) {
      connectToFigma();
      reject(new Error("Not connected to Figma. Attempting to connect..."));
      return;
    }
    const requiresChannel = command !== "join";
    if (requiresChannel && !currentChannel) {
      reject(new Error("Must join a channel before sending commands"));
      return;
    }
    const id = (0, import_uuid.v4)();
    const request = {
      id,
      type: command === "join" ? "join" : "message",
      ...command === "join" ? { channel: params.channel } : { channel: currentChannel },
      message: {
        id,
        command,
        params: {
          ...params,
          commandId: id
          // Include the command ID in params
        }
      }
    };
    const timeout = setTimeout(() => {
      if (pendingRequests.has(id)) {
        pendingRequests.delete(id);
        logger.error(`Request ${id} to Figma timed out after ${timeoutMs / 1e3} seconds`);
        reject(new Error("Request to Figma timed out"));
      }
    }, timeoutMs);
    pendingRequests.set(id, {
      resolve,
      reject,
      timeout,
      lastActivity: Date.now()
    });
    logger.info(`Sending command to Figma: ${command}`);
    logger.debug(`Request details: ${JSON.stringify(request)}`);
    ws.send(JSON.stringify(request));
  });
}

// src/talk_to_figma_mcp/tools/document-tools.ts
var import_zod = require("zod");

// src/talk_to_figma_mcp/utils/figma-helpers.ts
function rgbaToHex(color) {
  const r = Math.round(color.r * 255);
  const g = Math.round(color.g * 255);
  const b = Math.round(color.b * 255);
  const a = Math.round(color.a * 255);
  return `#${r.toString(16).padStart(2, "0")}${g.toString(16).padStart(2, "0")}${b.toString(16).padStart(2, "0")}${a === 255 ? "" : a.toString(16).padStart(2, "0")}`;
}
function filterFigmaNode(node) {
  if (node.type === "VECTOR") {
    return null;
  }
  const filtered = {
    id: node.id,
    name: node.name,
    type: node.type
  };
  if (node.fills && node.fills.length > 0) {
    filtered.fills = node.fills.map((fill) => {
      const processedFill = { ...fill };
      delete processedFill.boundVariables;
      delete processedFill.imageRef;
      if (processedFill.gradientStops) {
        processedFill.gradientStops = processedFill.gradientStops.map((stop) => {
          const processedStop = { ...stop };
          if (processedStop.color) {
            processedStop.color = rgbaToHex(processedStop.color);
          }
          delete processedStop.boundVariables;
          return processedStop;
        });
      }
      if (processedFill.color) {
        processedFill.color = rgbaToHex(processedFill.color);
      }
      return processedFill;
    });
  }
  if (node.strokes && node.strokes.length > 0) {
    filtered.strokes = node.strokes.map((stroke) => {
      const processedStroke = { ...stroke };
      delete processedStroke.boundVariables;
      if (processedStroke.color) {
        processedStroke.color = rgbaToHex(processedStroke.color);
      }
      return processedStroke;
    });
  }
  if (node.cornerRadius !== void 0) {
    filtered.cornerRadius = node.cornerRadius;
  }
  if (node.absoluteBoundingBox) {
    filtered.absoluteBoundingBox = node.absoluteBoundingBox;
  }
  if (node.characters) {
    filtered.characters = node.characters;
  }
  if (node.style) {
    filtered.style = {
      fontFamily: node.style.fontFamily,
      fontStyle: node.style.fontStyle,
      fontWeight: node.style.fontWeight,
      fontSize: node.style.fontSize,
      textAlignHorizontal: node.style.textAlignHorizontal,
      letterSpacing: node.style.letterSpacing,
      lineHeightPx: node.style.lineHeightPx
    };
  }
  if (node.children) {
    filtered.children = node.children.map((child) => filterFigmaNode(child)).filter((child) => child !== null);
  }
  return filtered;
}

// src/talk_to_figma_mcp/tools/document-tools.ts
function registerDocumentTools(server) {
  server.tool(
    "get_document_info",
    "Get detailed information about the current Figma document",
    {},
    async () => {
      try {
        const result = await sendCommandToFigma("get_document_info");
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting document info: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "get_selection",
    "Get information about the current selection in Figma",
    {},
    async () => {
      try {
        const result = await sendCommandToFigma("get_selection");
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting selection: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "get_node_info",
    "Get detailed information about a specific node in Figma",
    {
      nodeId: import_zod.z.string().describe("The ID of the node to get information about")
    },
    async ({ nodeId }) => {
      try {
        const result = await sendCommandToFigma("get_node_info", { nodeId });
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(filterFigmaNode(result))
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting node info: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "get_nodes_info",
    "Get detailed information about multiple nodes in Figma",
    {
      nodeIds: import_zod.z.array(import_zod.z.string()).describe("Array of node IDs to get information about")
    },
    async ({ nodeIds }) => {
      try {
        const results = await Promise.all(
          nodeIds.map(async (nodeId) => {
            const result = await sendCommandToFigma("get_node_info", { nodeId });
            return { nodeId, info: result };
          })
        );
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(results.map((result) => filterFigmaNode(result.info)))
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting nodes info: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "get_styles",
    "Get all styles from the current Figma document",
    {},
    async () => {
      try {
        const result = await sendCommandToFigma("get_styles");
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting styles: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "get_local_components",
    "Get all local components from the Figma document",
    {},
    async () => {
      try {
        const result = await sendCommandToFigma("get_local_components");
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting local components: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "get_remote_components",
    "Get available components from team libraries in Figma",
    {},
    async () => {
      try {
        const result = await sendCommandToFigma("get_remote_components");
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting remote components: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "scan_text_nodes",
    "Scan all text nodes in the selected Figma node",
    {
      nodeId: import_zod.z.string().describe("ID of the node to scan")
    },
    async ({ nodeId }) => {
      try {
        const initialStatus = {
          type: "text",
          text: "Starting text node scanning. This may take a moment for large designs..."
        };
        const result = await sendCommandToFigma("scan_text_nodes", {
          nodeId,
          useChunking: true,
          // Enable chunking on the plugin side
          chunkSize: 10
          // Process 10 nodes at a time
        });
        if (result && typeof result === "object" && "chunks" in result) {
          const typedResult = result;
          const summaryText = `
          Scan completed:
          - Found ${typedResult.totalNodes} text nodes
          - Processed in ${typedResult.chunks} chunks
          `;
          return {
            content: [
              initialStatus,
              {
                type: "text",
                text: summaryText
              },
              {
                type: "text",
                text: JSON.stringify(typedResult.textNodes, null, 2)
              }
            ]
          };
        }
        return {
          content: [
            initialStatus,
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error scanning text nodes: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "join_channel",
    "Join a specific channel to communicate with Figma",
    {
      channel: import_zod.z.string().describe("The name of the channel to join").default("")
    },
    async ({ channel }) => {
      try {
        if (!channel) {
          return {
            content: [
              {
                type: "text",
                text: "Please provide a channel name to join:"
              }
            ],
            followUp: {
              tool: "join_channel",
              description: "Join the specified channel"
            }
          };
        }
        await joinChannel(channel);
        return {
          content: [
            {
              type: "text",
              text: `Successfully joined channel: ${channel}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error joining channel: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "export_node_as_image",
    "Export a node as an image from Figma",
    {
      nodeId: import_zod.z.string().describe("The ID of the node to export"),
      format: import_zod.z.enum(["PNG", "JPG", "SVG", "PDF"]).optional().describe("Export format"),
      scale: import_zod.z.number().positive().optional().describe("Export scale")
    },
    async ({ nodeId, format, scale }) => {
      try {
        const result = await sendCommandToFigma("export_node_as_image", {
          nodeId,
          format: format || "PNG",
          scale: scale || 1
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "image",
              data: typedResult.imageData,
              mimeType: typedResult.mimeType || "image/png"
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error exporting node as image: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
}

// src/talk_to_figma_mcp/tools/creation-tools.ts
var import_zod2 = require("zod");
function registerCreationTools(server) {
  server.tool(
    "create_rectangle",
    "Create a new rectangle in Figma",
    {
      x: import_zod2.z.number().describe("X position"),
      y: import_zod2.z.number().describe("Y position"),
      width: import_zod2.z.number().describe("Width of the rectangle"),
      height: import_zod2.z.number().describe("Height of the rectangle"),
      name: import_zod2.z.string().optional().describe("Optional name for the rectangle"),
      parentId: import_zod2.z.string().optional().describe("Optional parent node ID to append the rectangle to")
    },
    async ({ x, y, width, height, name, parentId }) => {
      try {
        const result = await sendCommandToFigma("create_rectangle", {
          x,
          y,
          width,
          height,
          name: name || "Rectangle",
          parentId
        });
        return {
          content: [
            {
              type: "text",
              text: `Created rectangle "${JSON.stringify(result)}"`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating rectangle: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "create_frame",
    "Create a new frame in Figma",
    {
      x: import_zod2.z.number().describe("X position"),
      y: import_zod2.z.number().describe("Y position"),
      width: import_zod2.z.number().describe("Width of the frame"),
      height: import_zod2.z.number().describe("Height of the frame"),
      name: import_zod2.z.string().optional().describe("Optional name for the frame"),
      parentId: import_zod2.z.string().optional().describe("Optional parent node ID to append the frame to"),
      fillColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Fill color in RGBA format"),
      strokeColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Stroke color in RGBA format"),
      strokeWeight: import_zod2.z.number().positive().optional().describe("Stroke weight")
    },
    async ({
      x,
      y,
      width,
      height,
      name,
      parentId,
      fillColor,
      strokeColor,
      strokeWeight
    }) => {
      try {
        const result = await sendCommandToFigma("create_frame", {
          x,
          y,
          width,
          height,
          name: name || "Frame",
          parentId,
          fillColor: fillColor || { r: 1, g: 1, b: 1, a: 1 },
          strokeColor,
          strokeWeight
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Created frame "${typedResult.name}" with ID: ${typedResult.id}. Use the ID as the parentId to appendChild inside this frame.`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating frame: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "create_text",
    "Create a new text element in Figma",
    {
      x: import_zod2.z.number().describe("X position"),
      y: import_zod2.z.number().describe("Y position"),
      text: import_zod2.z.string().describe("Text content"),
      fontSize: import_zod2.z.number().optional().describe("Font size (default: 14)"),
      fontWeight: import_zod2.z.number().optional().describe("Font weight (e.g., 400 for Regular, 700 for Bold)"),
      fontColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Font color in RGBA format"),
      name: import_zod2.z.string().optional().describe("Optional name for the text node by default following text"),
      parentId: import_zod2.z.string().optional().describe("Optional parent node ID to append the text to")
    },
    async ({ x, y, text, fontSize, fontWeight, fontColor, name, parentId }) => {
      try {
        const result = await sendCommandToFigma("create_text", {
          x,
          y,
          text,
          fontSize: fontSize || 14,
          fontWeight: fontWeight || 400,
          fontColor: fontColor || { r: 0, g: 0, b: 0, a: 1 },
          name: name || "Text",
          parentId
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Created text "${typedResult.name}" with ID: ${typedResult.id}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating text: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "create_ellipse",
    "Create a new ellipse in Figma",
    {
      x: import_zod2.z.number().describe("X position"),
      y: import_zod2.z.number().describe("Y position"),
      width: import_zod2.z.number().describe("Width of the ellipse"),
      height: import_zod2.z.number().describe("Height of the ellipse"),
      name: import_zod2.z.string().optional().describe("Optional name for the ellipse"),
      parentId: import_zod2.z.string().optional().describe("Optional parent node ID to append the ellipse to"),
      fillColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Fill color in RGBA format"),
      strokeColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Stroke color in RGBA format"),
      strokeWeight: import_zod2.z.number().positive().optional().describe("Stroke weight")
    },
    async ({ x, y, width, height, name, parentId, fillColor, strokeColor, strokeWeight }) => {
      try {
        const result = await sendCommandToFigma("create_ellipse", {
          x,
          y,
          width,
          height,
          name: name || "Ellipse",
          parentId,
          fillColor,
          strokeColor,
          strokeWeight
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Created ellipse with ID: ${typedResult.id}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating ellipse: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "create_polygon",
    "Create a new polygon in Figma",
    {
      x: import_zod2.z.number().describe("X position"),
      y: import_zod2.z.number().describe("Y position"),
      width: import_zod2.z.number().describe("Width of the polygon"),
      height: import_zod2.z.number().describe("Height of the polygon"),
      sides: import_zod2.z.number().min(3).optional().describe("Number of sides (default: 6)"),
      name: import_zod2.z.string().optional().describe("Optional name for the polygon"),
      parentId: import_zod2.z.string().optional().describe("Optional parent node ID to append the polygon to"),
      fillColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Fill color in RGBA format"),
      strokeColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Stroke color in RGBA format"),
      strokeWeight: import_zod2.z.number().positive().optional().describe("Stroke weight")
    },
    async ({ x, y, width, height, sides, name, parentId, fillColor, strokeColor, strokeWeight }) => {
      try {
        const result = await sendCommandToFigma("create_polygon", {
          x,
          y,
          width,
          height,
          sides: sides || 6,
          name: name || "Polygon",
          parentId,
          fillColor,
          strokeColor,
          strokeWeight
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Created polygon with ID: ${typedResult.id} and ${sides || 6} sides`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating polygon: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "create_star",
    "Create a new star in Figma",
    {
      x: import_zod2.z.number().describe("X position"),
      y: import_zod2.z.number().describe("Y position"),
      width: import_zod2.z.number().describe("Width of the star"),
      height: import_zod2.z.number().describe("Height of the star"),
      points: import_zod2.z.number().min(3).optional().describe("Number of points (default: 5)"),
      innerRadius: import_zod2.z.number().min(0.01).max(0.99).optional().describe("Inner radius ratio (0.01-0.99, default: 0.5)"),
      name: import_zod2.z.string().optional().describe("Optional name for the star"),
      parentId: import_zod2.z.string().optional().describe("Optional parent node ID to append the star to"),
      fillColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Fill color in RGBA format"),
      strokeColor: import_zod2.z.object({
        r: import_zod2.z.number().min(0).max(1).describe("Red component (0-1)"),
        g: import_zod2.z.number().min(0).max(1).describe("Green component (0-1)"),
        b: import_zod2.z.number().min(0).max(1).describe("Blue component (0-1)"),
        a: import_zod2.z.number().min(0).max(1).optional().describe("Alpha component (0-1)")
      }).optional().describe("Stroke color in RGBA format"),
      strokeWeight: import_zod2.z.number().positive().optional().describe("Stroke weight")
    },
    async ({ x, y, width, height, points, innerRadius, name, parentId, fillColor, strokeColor, strokeWeight }) => {
      try {
        const result = await sendCommandToFigma("create_star", {
          x,
          y,
          width,
          height,
          points: points || 5,
          innerRadius: innerRadius || 0.5,
          name: name || "Star",
          parentId,
          fillColor,
          strokeColor,
          strokeWeight
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Created star with ID: ${typedResult.id}, ${points || 5} points, and inner radius ratio of ${innerRadius || 0.5}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating star: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "group_nodes",
    "Group nodes in Figma",
    {
      nodeIds: import_zod2.z.array(import_zod2.z.string()).describe("Array of IDs of the nodes to group"),
      name: import_zod2.z.string().optional().describe("Optional name for the group")
    },
    async ({ nodeIds, name }) => {
      try {
        const result = await sendCommandToFigma("group_nodes", {
          nodeIds,
          name
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Nodes successfully grouped into "${typedResult.name}" with ID: ${typedResult.id}. The group contains ${typedResult.children.length} elements.`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error grouping nodes: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "ungroup_nodes",
    "Ungroup nodes in Figma",
    {
      nodeId: import_zod2.z.string().describe("ID of the node (group or frame) to ungroup")
    },
    async ({ nodeId }) => {
      try {
        const result = await sendCommandToFigma("ungroup_nodes", { nodeId });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Node successfully ungrouped. ${typedResult.ungroupedCount} elements were released.`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error ungrouping node: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "clone_node",
    "Clone an existing node in Figma",
    {
      nodeId: import_zod2.z.string().describe("The ID of the node to clone"),
      x: import_zod2.z.number().optional().describe("New X position for the clone"),
      y: import_zod2.z.number().optional().describe("New Y position for the clone")
    },
    async ({ nodeId, x, y }) => {
      try {
        const result = await sendCommandToFigma("clone_node", { nodeId, x, y });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Cloned node "${typedResult.name}" with new ID: ${typedResult.id}${x !== void 0 && y !== void 0 ? ` at position (${x}, ${y})` : ""}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error cloning node: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "insert_child",
    "Insert a child node inside a parent node in Figma",
    {
      parentId: import_zod2.z.string().describe("ID of the parent node where the child will be inserted"),
      childId: import_zod2.z.string().describe("ID of the child node to insert"),
      index: import_zod2.z.number().optional().describe("Optional index where to insert the child (if not specified, it will be added at the end)")
    },
    async ({ parentId, childId, index }) => {
      try {
        const result = await sendCommandToFigma("insert_child", {
          parentId,
          childId,
          index
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Child node with ID: ${typedResult.childId} successfully inserted into parent node with ID: ${typedResult.parentId}${index !== void 0 ? ` at position ${typedResult.index}` : ""}.`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error inserting child node: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "flatten_node",
    "Flatten a node in Figma (e.g., for boolean operations or converting to path)",
    {
      nodeId: import_zod2.z.string().describe("ID of the node to flatten")
    },
    async ({ nodeId }) => {
      try {
        const result = await sendCommandToFigma("flatten_node", { nodeId });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Node "${typedResult.name}" flattened successfully. The new node has ID: ${typedResult.id} and is of type ${typedResult.type}.`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error flattening node: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
}

// src/talk_to_figma_mcp/tools/modification-tools.ts
var import_zod3 = require("zod");

// src/talk_to_figma_mcp/utils/defaults.ts
var FIGMA_DEFAULTS = {
  color: {
    opacity: 1
  },
  stroke: {
    weight: 1
  }
};
function applyDefault(value, defaultValue) {
  return value !== void 0 ? value : defaultValue;
}
function applyColorDefaults(color) {
  return {
    r: color.r,
    g: color.g,
    b: color.b,
    a: applyDefault(color.a, FIGMA_DEFAULTS.color.opacity)
  };
}

// src/talk_to_figma_mcp/tools/modification-tools.ts
function registerModificationTools(server) {
  server.tool(
    "set_fill_color",
    "Set the fill color of a node in Figma. Alpha component defaults to 1 (fully opaque) if not specified. Use alpha 0 for fully transparent.",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to modify"),
      r: import_zod3.z.number().min(0).max(1).describe("Red component (0-1)"),
      g: import_zod3.z.number().min(0).max(1).describe("Green component (0-1)"),
      b: import_zod3.z.number().min(0).max(1).describe("Blue component (0-1)"),
      a: import_zod3.z.number().min(0).max(1).optional().describe("Alpha component (0-1, defaults to 1 if not specified)")
    },
    async ({ nodeId, r, g, b, a }) => {
      try {
        if (r === void 0 || g === void 0 || b === void 0) {
          throw new Error("RGB components (r, g, b) are required and cannot be undefined");
        }
        const colorInput = { r, g, b, a };
        const colorWithDefaults = applyColorDefaults(colorInput);
        const result = await sendCommandToFigma("set_fill_color", {
          nodeId,
          color: colorWithDefaults
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Set fill color of node "${typedResult.name}" to RGBA(${r}, ${g}, ${b}, ${colorWithDefaults.a})`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting fill color: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_stroke_color",
    "Set the stroke color of a node in Figma (defaults: opacity 1, weight 1)",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to modify"),
      r: import_zod3.z.number().min(0).max(1).describe("Red component (0-1)"),
      g: import_zod3.z.number().min(0).max(1).describe("Green component (0-1)"),
      b: import_zod3.z.number().min(0).max(1).describe("Blue component (0-1)"),
      a: import_zod3.z.number().min(0).max(1).optional().describe("Alpha component (0-1)"),
      strokeWeight: import_zod3.z.number().positive().optional().describe("Stroke weight")
    },
    async ({ nodeId, r, g, b, a, strokeWeight }) => {
      try {
        if (r === void 0 || g === void 0 || b === void 0) {
          throw new Error("RGB components (r, g, b) are required and cannot be undefined");
        }
        const colorInput = { r, g, b, a };
        const colorWithDefaults = applyColorDefaults(colorInput);
        const strokeWeightWithDefault = applyDefault(strokeWeight, FIGMA_DEFAULTS.stroke.weight);
        const result = await sendCommandToFigma("set_stroke_color", {
          nodeId,
          color: colorWithDefaults,
          strokeWeight: strokeWeightWithDefault
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Set stroke color of node "${typedResult.name}" to RGBA(${r}, ${g}, ${b}, ${colorWithDefaults.a}) with weight ${strokeWeightWithDefault}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting stroke color: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "move_node",
    "Move a node to a new position in Figma",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to move"),
      x: import_zod3.z.number().describe("New X position"),
      y: import_zod3.z.number().describe("New Y position")
    },
    async ({ nodeId, x, y }) => {
      try {
        const result = await sendCommandToFigma("move_node", { nodeId, x, y });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Moved node "${typedResult.name}" to position (${x}, ${y})`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error moving node: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "resize_node",
    "Resize a node in Figma",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to resize"),
      width: import_zod3.z.number().positive().describe("New width"),
      height: import_zod3.z.number().positive().describe("New height")
    },
    async ({ nodeId, width, height }) => {
      try {
        const result = await sendCommandToFigma("resize_node", {
          nodeId,
          width,
          height
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Resized node "${typedResult.name}" to width ${width} and height ${height}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error resizing node: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "delete_node",
    "Delete a node from Figma",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to delete")
    },
    async ({ nodeId }) => {
      try {
        await sendCommandToFigma("delete_node", { nodeId });
        return {
          content: [
            {
              type: "text",
              text: `Deleted node with ID: ${nodeId}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error deleting node: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_corner_radius",
    "Set the corner radius of a node in Figma",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to modify"),
      radius: import_zod3.z.number().min(0).describe("Corner radius value"),
      corners: import_zod3.z.array(import_zod3.z.boolean()).length(4).optional().describe(
        "Optional array of 4 booleans to specify which corners to round [topLeft, topRight, bottomRight, bottomLeft]"
      )
    },
    async ({ nodeId, radius, corners }) => {
      try {
        const result = await sendCommandToFigma("set_corner_radius", {
          nodeId,
          radius,
          corners: corners || [true, true, true, true]
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Set corner radius of node "${typedResult.name}" to ${radius}px`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting corner radius: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_auto_layout",
    "Configure auto layout properties for a node in Figma",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to configure auto layout"),
      layoutMode: import_zod3.z.enum(["HORIZONTAL", "VERTICAL", "NONE"]).describe("Layout direction"),
      paddingTop: import_zod3.z.number().optional().describe("Top padding in pixels"),
      paddingBottom: import_zod3.z.number().optional().describe("Bottom padding in pixels"),
      paddingLeft: import_zod3.z.number().optional().describe("Left padding in pixels"),
      paddingRight: import_zod3.z.number().optional().describe("Right padding in pixels"),
      itemSpacing: import_zod3.z.number().optional().describe("Spacing between items in pixels"),
      primaryAxisAlignItems: import_zod3.z.enum(["MIN", "CENTER", "MAX", "SPACE_BETWEEN"]).optional().describe("Alignment along primary axis"),
      counterAxisAlignItems: import_zod3.z.enum(["MIN", "CENTER", "MAX"]).optional().describe("Alignment along counter axis"),
      layoutWrap: import_zod3.z.enum(["WRAP", "NO_WRAP"]).optional().describe("Whether items wrap to new lines"),
      strokesIncludedInLayout: import_zod3.z.boolean().optional().describe("Whether strokes are included in layout calculations")
    },
    async ({
      nodeId,
      layoutMode,
      paddingTop,
      paddingBottom,
      paddingLeft,
      paddingRight,
      itemSpacing,
      primaryAxisAlignItems,
      counterAxisAlignItems,
      layoutWrap,
      strokesIncludedInLayout
    }) => {
      try {
        const result = await sendCommandToFigma("set_auto_layout", {
          nodeId,
          layoutMode,
          paddingTop,
          paddingBottom,
          paddingLeft,
          paddingRight,
          itemSpacing,
          primaryAxisAlignItems,
          counterAxisAlignItems,
          layoutWrap,
          strokesIncludedInLayout
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Applied auto layout to node "${typedResult.name}" with mode: ${layoutMode}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting auto layout: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_effects",
    "Set the visual effects of a node in Figma",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to modify"),
      effects: import_zod3.z.array(
        import_zod3.z.object({
          type: import_zod3.z.enum(["DROP_SHADOW", "INNER_SHADOW", "LAYER_BLUR", "BACKGROUND_BLUR"]).describe("Effect type"),
          color: import_zod3.z.object({
            r: import_zod3.z.number().min(0).max(1).describe("Red (0-1)"),
            g: import_zod3.z.number().min(0).max(1).describe("Green (0-1)"),
            b: import_zod3.z.number().min(0).max(1).describe("Blue (0-1)"),
            a: import_zod3.z.number().min(0).max(1).describe("Alpha (0-1)")
          }).optional().describe("Effect color (for shadows)"),
          offset: import_zod3.z.object({
            x: import_zod3.z.number().describe("X offset"),
            y: import_zod3.z.number().describe("Y offset")
          }).optional().describe("Offset (for shadows)"),
          radius: import_zod3.z.number().optional().describe("Effect radius"),
          spread: import_zod3.z.number().optional().describe("Shadow spread (for shadows)"),
          visible: import_zod3.z.boolean().optional().describe("Whether the effect is visible"),
          blendMode: import_zod3.z.string().optional().describe("Blend mode")
        })
      ).describe("Array of effects to apply")
    },
    async ({ nodeId, effects }) => {
      try {
        const result = await sendCommandToFigma("set_effects", {
          nodeId,
          effects
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Successfully applied ${effects.length} effect(s) to node "${typedResult.name}"`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting effects: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_effect_style_id",
    "Apply an effect style to a node in Figma",
    {
      nodeId: import_zod3.z.string().describe("The ID of the node to modify"),
      effectStyleId: import_zod3.z.string().describe("The ID of the effect style to apply")
    },
    async ({ nodeId, effectStyleId }) => {
      try {
        const result = await sendCommandToFigma("set_effect_style_id", {
          nodeId,
          effectStyleId
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Successfully applied effect style to node "${typedResult.name}"`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting effect style: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
}

// src/talk_to_figma_mcp/tools/text-tools.ts
var import_zod4 = require("zod");
function registerTextTools(server) {
  server.tool(
    "set_text_content",
    "Set the text content of an existing text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      text: import_zod4.z.string().describe("New text content")
    },
    async ({ nodeId, text }) => {
      try {
        const result = await sendCommandToFigma("set_text_content", {
          nodeId,
          text
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated text content of node "${typedResult.name}" to "${text}"`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting text content: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_multiple_text_contents",
    "Set multiple text contents parallelly in a node",
    {
      nodeId: import_zod4.z.string().describe("The ID of the node containing the text nodes to replace"),
      text: import_zod4.z.array(
        import_zod4.z.object({
          nodeId: import_zod4.z.string().describe("The ID of the text node"),
          text: import_zod4.z.string().describe("The replacement text")
        })
      ).describe("Array of text node IDs and their replacement texts")
    },
    async ({ nodeId, text }, extra) => {
      try {
        if (!text || text.length === 0) {
          return {
            content: [
              {
                type: "text",
                text: "No text provided"
              }
            ]
          };
        }
        const initialStatus = {
          type: "text",
          text: `Starting text replacement for ${text.length} nodes. This will be processed in batches of 5...`
        };
        let totalProcessed = 0;
        const totalToProcess = text.length;
        const result = await sendCommandToFigma("set_multiple_text_contents", {
          nodeId,
          text
        });
        const typedResult = result;
        const success = typedResult.replacementsApplied && typedResult.replacementsApplied > 0;
        const progressText = `
        Text replacement completed:
        - ${typedResult.replacementsApplied || 0} of ${totalToProcess} successfully updated
        - ${typedResult.replacementsFailed || 0} failed
        - Processed in ${typedResult.completedInChunks || 1} batches
        `;
        const detailedResults = typedResult.results || [];
        const failedResults = detailedResults.filter((item) => !item.success);
        let detailedResponse = "";
        if (failedResults.length > 0) {
          detailedResponse = `

Nodes that failed:
${failedResults.map(
            (item) => `- ${item.nodeId}: ${item.error || "Unknown error"}`
          ).join("\n")}`;
        }
        return {
          content: [
            initialStatus,
            {
              type: "text",
              text: progressText + detailedResponse
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting multiple text contents: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_font_name",
    "Set the font name and style of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      family: import_zod4.z.string().describe("Font family name"),
      style: import_zod4.z.string().optional().describe("Font style (e.g., 'Regular', 'Bold', 'Italic')")
    },
    async ({ nodeId, family, style }) => {
      try {
        const result = await sendCommandToFigma("set_font_name", {
          nodeId,
          family,
          style
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated font of node "${typedResult.name}" to ${typedResult.fontName.family} ${typedResult.fontName.style}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting font name: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_font_size",
    "Set the font size of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      fontSize: import_zod4.z.number().positive().describe("Font size in pixels")
    },
    async ({ nodeId, fontSize }) => {
      try {
        const result = await sendCommandToFigma("set_font_size", {
          nodeId,
          fontSize
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated font size of node "${typedResult.name}" to ${typedResult.fontSize}px`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting font size: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_font_weight",
    "Set the font weight of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      weight: import_zod4.z.number().describe("Font weight (100, 200, 300, 400, 500, 600, 700, 800, 900)")
    },
    async ({ nodeId, weight }) => {
      try {
        const result = await sendCommandToFigma("set_font_weight", {
          nodeId,
          weight
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated font weight of node "${typedResult.name}" to ${typedResult.weight} (${typedResult.fontName.style})`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting font weight: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_letter_spacing",
    "Set the letter spacing of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      letterSpacing: import_zod4.z.number().describe("Letter spacing value"),
      unit: import_zod4.z.enum(["PIXELS", "PERCENT"]).optional().describe("Unit type (PIXELS or PERCENT)")
    },
    async ({ nodeId, letterSpacing, unit }) => {
      try {
        const result = await sendCommandToFigma("set_letter_spacing", {
          nodeId,
          letterSpacing,
          unit: unit || "PIXELS"
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated letter spacing of node "${typedResult.name}" to ${typedResult.letterSpacing.value} ${typedResult.letterSpacing.unit}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting letter spacing: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_line_height",
    "Set the line height of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      lineHeight: import_zod4.z.number().describe("Line height value"),
      unit: import_zod4.z.enum(["PIXELS", "PERCENT", "AUTO"]).optional().describe("Unit type (PIXELS, PERCENT, or AUTO)")
    },
    async ({ nodeId, lineHeight, unit }) => {
      try {
        const result = await sendCommandToFigma("set_line_height", {
          nodeId,
          lineHeight,
          unit: unit || "PIXELS"
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated line height of node "${typedResult.name}" to ${typedResult.lineHeight.value} ${typedResult.lineHeight.unit}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting line height: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_paragraph_spacing",
    "Set the paragraph spacing of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      paragraphSpacing: import_zod4.z.number().describe("Paragraph spacing value in pixels")
    },
    async ({ nodeId, paragraphSpacing }) => {
      try {
        const result = await sendCommandToFigma("set_paragraph_spacing", {
          nodeId,
          paragraphSpacing
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated paragraph spacing of node "${typedResult.name}" to ${typedResult.paragraphSpacing}px`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting paragraph spacing: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_text_case",
    "Set the text case of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      textCase: import_zod4.z.enum(["ORIGINAL", "UPPER", "LOWER", "TITLE"]).describe("Text case type")
    },
    async ({ nodeId, textCase }) => {
      try {
        const result = await sendCommandToFigma("set_text_case", {
          nodeId,
          textCase
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated text case of node "${typedResult.name}" to ${typedResult.textCase}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting text case: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "set_text_decoration",
    "Set the text decoration of a text node in Figma",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to modify"),
      textDecoration: import_zod4.z.enum(["NONE", "UNDERLINE", "STRIKETHROUGH"]).describe("Text decoration type")
    },
    async ({ nodeId, textDecoration }) => {
      try {
        const result = await sendCommandToFigma("set_text_decoration", {
          nodeId,
          textDecoration
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: `Updated text decoration of node "${typedResult.name}" to ${typedResult.textDecoration}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error setting text decoration: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "get_styled_text_segments",
    "Get text segments with specific styling in a text node",
    {
      nodeId: import_zod4.z.string().describe("The ID of the text node to analyze"),
      property: import_zod4.z.enum([
        "fillStyleId",
        "fontName",
        "fontSize",
        "textCase",
        "textDecoration",
        "textStyleId",
        "fills",
        "letterSpacing",
        "lineHeight",
        "fontWeight"
      ]).describe("The style property to analyze segments by")
    },
    async ({ nodeId, property }) => {
      try {
        const result = await sendCommandToFigma("get_styled_text_segments", {
          nodeId,
          property
        });
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(result, null, 2)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error getting styled text segments: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
  server.tool(
    "load_font_async",
    "Load a font asynchronously in Figma",
    {
      family: import_zod4.z.string().describe("Font family name"),
      style: import_zod4.z.string().optional().describe("Font style (e.g., 'Regular', 'Bold', 'Italic')")
    },
    async ({ family, style }) => {
      try {
        const result = await sendCommandToFigma("load_font_async", {
          family,
          style: style || "Regular"
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: typedResult.message || `Loaded font ${family} ${style || "Regular"}`
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error loading font: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
}

// src/talk_to_figma_mcp/tools/component-tools.ts
var import_zod5 = require("zod");
function registerComponentTools(server) {
  server.tool(
    "create_component_instance",
    "Create an instance of a component in Figma",
    {
      componentKey: import_zod5.z.string().describe("Key of the component to instantiate"),
      x: import_zod5.z.number().describe("X position"),
      y: import_zod5.z.number().describe("Y position")
    },
    async ({ componentKey, x, y }) => {
      try {
        const result = await sendCommandToFigma("create_component_instance", {
          componentKey,
          x,
          y
        });
        const typedResult = result;
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(typedResult)
            }
          ]
        };
      } catch (error) {
        return {
          content: [
            {
              type: "text",
              text: `Error creating component instance: ${error instanceof Error ? error.message : String(error)}`
            }
          ]
        };
      }
    }
  );
}

// src/talk_to_figma_mcp/tools/index.ts
function registerTools(server) {
  registerDocumentTools(server);
  registerCreationTools(server);
  registerModificationTools(server);
  registerTextTools(server);
  registerComponentTools(server);
}

// src/talk_to_figma_mcp/prompts/index.ts
function registerPrompts(server) {
  server.prompt(
    "design_strategy",
    "Best practices for working with Figma designs",
    (extra) => {
      return {
        messages: [
          {
            role: "assistant",
            content: {
              type: "text",
              text: `When working with Figma designs, follow these best practices:

1. Start with Document Structure:
   - First use get_document_info() to understand the current document
   - Plan your layout hierarchy before creating elements
   - Create a main container frame for each screen/section

2. Naming Conventions:
   - Use descriptive, semantic names for all elements
   - Follow a consistent naming pattern (e.g., "Login Screen", "Logo Container", "Email Input")
   - Group related elements with meaningful names

3. Layout Hierarchy:
   - Create parent frames first, then add child elements
   - For forms/login screens:
     * Start with the main screen container frame
     * Create a logo container at the top
     * Group input fields in their own containers
     * Place action buttons (login, submit) after inputs
     * Add secondary elements (forgot password, signup links) last

4. Input Fields Structure:
   - Create a container frame for each input field
   - Include a label text above or inside the input
   - Group related inputs (e.g., username/password) together

5. Element Creation:
   - Use create_frame() for containers and input fields
   - Use create_text() for labels, buttons text, and links
   - Set appropriate colors and styles:
     * Use fillColor for backgrounds
     * Use strokeColor for borders
     * Set proper fontWeight for different text elements

6. Mofifying existing elements:
  - use set_text_content() to modify text content.

7. Visual Hierarchy:
   - Position elements in logical reading order (top to bottom)
   - Maintain consistent spacing between elements
   - Use appropriate font sizes for different text types:
     * Larger for headings/welcome text
     * Medium for input labels
     * Standard for button text
     * Smaller for helper text/links

8. Best Practices:
   - Verify each creation with get_node_info()
   - Use parentId to maintain proper hierarchy
   - Group related elements together in frames
   - Keep consistent spacing and alignment

Example Login Screen Structure:
- Login Screen (main frame)
  - Logo Container (frame)
    - Logo (image/text)
  - Welcome Text (text)
  - Input Container (frame)
    - Email Input (frame)
      - Email Label (text)
      - Email Field (frame)
    - Password Input (frame)
      - Password Label (text)
      - Password Field (frame)
  - Login Button (frame)
    - Button Text (text)
  - Helper Links (frame)
    - Forgot Password (text)
    - Don't have account (text)`
            }
          }
        ],
        description: "Best practices for working with Figma designs"
      };
    }
  );
  server.prompt(
    "read_design_strategy",
    "Best practices for reading Figma designs",
    (extra) => {
      return {
        messages: [
          {
            role: "assistant",
            content: {
              type: "text",
              text: `When reading Figma designs, follow these best practices:

1. Start with selection:
   - First use get_selection() to understand the current selection
   - If no selection ask user to select single or multiple nodes

2. Get node infos of the selected nodes:
   - Use get_nodes_info() to get the information of the selected nodes
   - If no selection ask user to select single or multiple nodes
`
            }
          }
        ],
        description: "Best practices for reading Figma designs"
      };
    }
  );
  server.prompt(
    "text_replacement_strategy",
    "Systematic approach for replacing text in Figma designs",
    (extra) => {
      return {
        messages: [
          {
            role: "assistant",
            content: {
              type: "text",
              text: `# Intelligent Text Replacement Strategy

## 1. Analyze Design & Identify Structure
- Scan text nodes to understand the overall structure of the design
- Use AI pattern recognition to identify logical groupings:
  * Tables (rows, columns, headers, cells)
  * Lists (items, headers, nested lists)
  * Card groups (similar cards with recurring text fields)
  * Forms (labels, input fields, validation text)
  * Navigation (menu items, breadcrumbs)
\`\`\`
scan_text_nodes(nodeId: "node-id")
get_node_info(nodeId: "node-id")  // optional
\`\`\`

## 2. Strategic Chunking for Complex Designs
- Divide replacement tasks into logical content chunks based on design structure
- Use one of these chunking strategies that best fits the design:
  * **Structural Chunking**: Table rows/columns, list sections, card groups
  * **Spatial Chunking**: Top-to-bottom, left-to-right in screen areas
  * **Semantic Chunking**: Content related to the same topic or functionality
  * **Component-Based Chunking**: Process similar component instances together

## 3. Progressive Replacement with Verification
- Create a safe copy of the node for text replacement
- Replace text chunk by chunk with continuous progress updates
- After each chunk is processed:
  * Export that section as a small, manageable image
  * Verify text fits properly and maintain design integrity
  * Fix issues before proceeding to the next chunk

\`\`\`
// Clone the node to create a safe copy
clone_node(nodeId: "selected-node-id", x: [new-x], y: [new-y])

// Replace text chunk by chunk
set_multiple_text_contents(
  nodeId: "parent-node-id", 
  text: [
    { nodeId: "node-id-1", text: "New text 1" },
    // More nodes in this chunk...
  ]
)

// Verify chunk with small, targeted image exports
export_node_as_image(nodeId: "chunk-node-id", format: "PNG", scale: 0.5)
\`\`\`

## 4. Intelligent Handling for Table Data
- For tabular content:
  * Process one row or column at a time
  * Maintain alignment and spacing between cells
  * Consider conditional formatting based on cell content
  * Preserve header/data relationships

## 5. Smart Text Adaptation
- Adaptively handle text based on container constraints:
  * Auto-detect space constraints and adjust text length
  * Apply line breaks at appropriate linguistic points
  * Maintain text hierarchy and emphasis
  * Consider font scaling for critical content that must fit

## 6. Progressive Feedback Loop
- Establish a continuous feedback loop during replacement:
  * Real-time progress updates (0-100%)
  * Small image exports after each chunk for verification
  * Issues identified early and resolved incrementally
  * Quick adjustments applied to subsequent chunks

## 7. Final Verification & Context-Aware QA
- After all chunks are processed:
  * Export the entire design at reduced scale for final verification
  * Check for cross-chunk consistency issues
  * Verify proper text flow between different sections
  * Ensure design harmony across the full composition

## 8. Chunk-Specific Export Scale Guidelines
- Scale exports appropriately based on chunk size:
  * Small chunks (1-5 elements): scale 1.0
  * Medium chunks (6-20 elements): scale 0.7
  * Large chunks (21-50 elements): scale 0.5
  * Very large chunks (50+ elements): scale 0.3
  * Full design verification: scale 0.2

## Sample Chunking Strategy for Common Design Types

### Tables
- Process by logical rows (5-10 rows per chunk)
- Alternative: Process by column for columnar analysis
- Tip: Always include header row in first chunk for reference

### Card Lists
- Group 3-5 similar cards per chunk
- Process entire cards to maintain internal consistency
- Verify text-to-image ratio within cards after each chunk

### Forms
- Group related fields (e.g., "Personal Information", "Payment Details")
- Process labels and input fields together
- Ensure validation messages and hints are updated with their fields

### Navigation & Menus
- Process hierarchical levels together (main menu, submenu)
- Respect information architecture relationships
- Verify menu fit and alignment after replacement

## Best Practices
- **Preserve Design Intent**: Always prioritize design integrity
- **Structural Consistency**: Maintain alignment, spacing, and hierarchy
- **Visual Feedback**: Verify each chunk visually before proceeding
- **Incremental Improvement**: Learn from each chunk to improve subsequent ones
- **Balance Automation & Control**: Let AI handle repetitive replacements but maintain oversight
- **Respect Content Relationships**: Keep related content consistent across chunks

Remember that text is never just text\u2014it's a core design element that must work harmoniously with the overall composition. This chunk-based strategy allows you to methodically transform text while maintaining design integrity.`
            }
          }
        ],
        description: "Systematic approach for replacing text in Figma designs"
      };
    }
  );
}

// src/talk_to_figma_mcp/server.ts
async function main() {
  try {
    const server = new import_mcp.McpServer(SERVER_CONFIG);
    registerTools(server);
    registerPrompts(server);
    try {
      connectToFigma();
    } catch (error) {
      logger.warn(`Could not connect to Figma initially: ${error instanceof Error ? error.message : String(error)}`);
      logger.warn("Will try to connect when the first command is sent");
    }
    const transport = new import_stdio.StdioServerTransport();
    await server.connect(transport);
    logger.info("FigmaMCP server running on stdio");
  } catch (error) {
    logger.error(`Error starting FigmaMCP server: ${error instanceof Error ? error.message : String(error)}`);
    process.exit(1);
  }
}
main().catch((error) => {
  logger.error(`Error starting FigmaMCP server: ${error instanceof Error ? error.message : String(error)}`);
  process.exit(1);
});
//# sourceMappingURL=server.cjs.map